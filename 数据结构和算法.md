# 基础数据结构
基础的东西还是会忘，目标是总结常用数据结构的定义，以及python底层实现

## 一、底层结构（物理结构）
### 1、 数组
按照目前的定义，数组是一整块连续的内存地址
特点：数据连续，支持快速随机访问
> 为什么支持随机访问？为什么访问快速？
随机访问是指访问一个中间元素时不需要经过前面的元素；访问快速的原因是知道头元素的位置，根据内存位置计算就可以得到目标的位置，时间复杂度O(1)
### 2、链表
链表的物理结构与数组不同，由离散的内存地址构建的存储结构

> 为什么说上述两个是底层机构呢？
我的理解，也许数组和链表两个名词不是很准确，但反映的是两种最基础的数据结构底层实现逻辑，即：内存是连续的还是离散的。但是在python中数组指的并不是物理结构，而是一种逻辑结构，即上层的数据结构--线性表。

## 二、上层结构（逻辑结果）

### 1、线性表
定义：1）只有一个开始元素，2）只有一个结束元素，3）除开始和结束外，每个元素都只有一个前驱和一个后继
实现方式：
- 数组
- 链式存储
	- 单链表：节点只往后指
	- 双向链表：尾节点指向头节点
	- 循环链表：节点往前往后都可以指

目标功能：
```
ADT List：
   List(self)           #创建一个新表
   is_empty(self)       #判断self是否是一个空表
   len(self)            #返回表长度
   prepend(self,elem)   #在表头插入元素
   append(self,elem)    #在表尾加入元素
   insert(self,elem,i)  #在表的位置i处插入元素
   del_first(self)      #删除第一个元素
   def_last(self)       #删除最后一个元素
   del(self,i)          #删除第I个元素
   search(self,elem)    #查找元素在表中第一次出现的位置
   forall(self,op)      #对表元素的遍历操作，op操作
```

参考文章：
- python列表和元组：https://www.jianshu.com/p/24090fb63968
- 实现单链表，看看就行屁用没有：https://m.yisu.com/zixun/158827.html
- python list原理：https://zhuanlan.zhihu.com/p/143223943

```python
# 其实在python中没必要实现线性表，list类型足够用，但是即便如此，也应该了解list是如何实现的
# 单链表
class LNode():
    def __init__(self, value, next_=None):
        self.value = value
        self.next = next_
class LineLinkedList():
    def __init__(self):
        self.head = None
        self.num = 0
# 累了，不想写了。。，
# 双链表要加个唯一id识别出头节点
# 循环链表就再加个指向前面的属性

# 别人的
class Node(object):
    """节点"""

    def __init__(self, elem):
        self.elem = elem
        self.next = None # 初始设置下一节点为空


class SingleLinkList(object):
    """单链表"""

    def __init__(self, node=None): # 使用一个默认参数，在传入头节点时则接收，在没有传入时，就默认头节点为空
        self.__head = node

    def is_empty(self):
        '''链表是否为空'''
        return self.__head == None

    def length(self):
        '''链表长度'''
        # cur游标，用来移动遍历节点
        cur = self.__head
        # count记录数量
        count = 0
        while cur != None:
            count += 1
            cur = cur.next
        return count

    def travel(self):
        '''遍历整个列表'''
        cur = self.__head
        while cur != None:
            print(cur.elem, end=' ')
            cur = cur.next
        print("\n")

    def add(self, item):
        '''链表头部添加元素'''
        node = Node(item)
        node.next = self.__head
        self.__head = node

    def append(self, item):
        '''链表尾部添加元素'''
        node = Node(item)
        # 由于特殊情况当链表为空时没有next，所以在前面要做个判断
        if self.is_empty():
            self.__head = node
        else:
            cur = self.__head
            while cur.next != None:
                cur = cur.next
            cur.next = node

    def insert(self, pos, item):
        '''指定位置添加元素'''
        if pos <= 0:
                # 如果pos位置在0或者以前，那么都当做头插法来做
            self.add(item)
        elif pos > self.length() - 1:
            # 如果pos位置比原链表长，那么都当做尾插法来做
            self.append(item)
        else:
            per = self.__head
            count = 0
            while count < pos - 1:
                count += 1
                per = per.next
            # 当循环退出后，pre指向pos-1位置
            node = Node(item)
            node.next = per.next
            per.next = node

    def remove(self, item):
        '''删除节点'''
        cur = self.__head
        pre = None
        while cur != None:
            if cur.elem == item:
                # 先判断该节点是否是头结点
                if cur == self.__head:
                    self.__head = cur.next
                else:
                    pre.next = cur.next
                break
            else:
                pre = cur
                cur = cur.next

    def search(self, item):
        '''查找节点是否存在'''
        cur = self.__head
        while not cur:
            if cur.elem == item:
                return True
            else:
                cur = cur.next
        return False
```

问题：
- 1、python内部的数组是如何实现的？

```
# cpython中list的定义
typedef struct {
    PyObject_VAR_HEAD
    PyObject **ob_item;
    Py_ssize_t allocated;
} PyListObject;
```
首先python中的数组是`动态数组`，基本由cpython实现，PyObject是指向列表元素的指针列表，allocated是在内存中分配的插槽数，一般插槽数大于len，这样添加元素时，如果插槽数还剩余就不用申请空间；一旦超过，就需要申请新的空间，每次申请的插槽数不一样，以某种规律增长。
```
# resize
arguments: list object, new size
returns: 0 if OK, -1 if not
list_resize:
    new_allocated = (newsize >> 3) + (newsize < 9 ? 3 : 6) = 3
    new_allocated += newsize = 3 + 1 = 4
    resize ob_item (list of pointers) to size new_allocated
    return 0
# >>：移位运算符
# condition ? value1: value2: 条件判断府，如果符合就是value1，不然value2
```
其次复杂度分析，Appand 操作的时间复杂度 O(1)，Insert 操作的复杂度为O(n)，Pop 操作的复杂度为 O(1)，Remove操作的复杂度为O(n)，都挺好理解的，但是值得注意的是`当删除元素导致列表元素数量小于插槽数一半的时候，插槽数也会减少，即预设的内存会减少`

- 2、python可以实现内存申请吗，像c语言中的数组一样？

在python中tuple很像c语言的数组，创建后不可删除，修改；但是可以实现两个元组的合并，逻辑也很简单，新创建一个元组，读取已有元组中的元素复制到新元组中；元组相较于数组，除了保证数据安全外， 是更加内存友好的结构，即`占用内存更少、创建速度更快、与python普通回收不同，元组删除后，内存不会立刻返回给os暂留，可避免频繁与os交互`（这应该是优势吧？暂留真的不会影响效率吗？）

### 2、栈
后进先出
``` python
class Stack:
  def __init__(self, *args):
            self.stack = list(args)
    def push(self, element):
            self.stack.append(element)
    def pop(self):
            return self.stack.pop()
    def __str__(self):
            return str(self.stack)
# 其他方法就不写了，懒
```
其实基本思想没啥特别的，总结几个面试类型
1. 括号匹配
2. 两个栈实现队列
3. 栈的压入、弹出序列


- 括号的很基础
- 两个栈的是一个进，一个出，当出的栈为空的时候就把进栈的元素压入出栈，然后在输出
- 这个是判断弹出序列是否是对的，其实可以简化为判断输入输出序列中是否存在连续的两个数字，用指针就可以解决；当然也可以真的去压入一遍，时刻比较栈顶元素与输出元素是否一致，全部压入之后，如果还是有剩余元素，则不一致

### 3、队列
先进先出，只允许队头删除，队尾插入
``` python
class Queue:
    def __init__(self, *args):
            self.queue = list(args)
    def enqueue(self, element):
            self.queue.append(element)
    def dequeue(self):
            last = self.queue[0]
            del self.queue[0]
            return last
    def __str__(self):
            return str(self.queue)
# 这样写也算，但意义不大
```

介绍python中的队列类
- collections.deque：双端队列，结合了栈和队列的类型，可操作队头队尾的插入和删除
- Queue：这个类最初是在多线程的时候用到

### 4、二叉树
参考：
树相关的属性和性质：https://www.cnblogs.com/guoyaohua/p/8595289.html
二叉树的性质：https://www.jianshu.com/p/20c8881c6b86
各种树的定义：https://blog.csdn.net/u014532217/article/details/79118023
二叉搜索树(BST)与平衡二叉树(AVL树)专题：https://blog.csdn.net/DaveBobo/article/details/77603549
构建二叉树：https://developer.aliyun.com/article/616378
构建二叉树python实现：https://www.pythonf.cn/read/134131
二叉树的删除操作：https://blog.csdn.net/zxnsirius/article/details/52131433

#### 1、树的类型
- 无序树
树的任意节点的子节点没有顺序关系。
- 有序树
树的任意节点的子节点有顺序关系。
- 二叉树
树的任意节点至多包含两棵子树。
- 满二叉树
叶子节点都在同一层并且除叶子节点外的所有节点都有两个子节点。
- 完全二叉树
对于一颗二叉树，假设其深度为d（d>1）。除第d层外的所有节点构成满二叉树，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树；
PS：这里的满二叉树和完全二叉树取的是国内的定义，国外的定义不一样，有兴趣的可以去看看国外的定义。
- 平衡二叉树（AVL）
它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树，同时，`平衡二叉树必定是二叉搜索树`，因为平衡二叉树是在二叉搜索树的基础上实现的
- 二叉查找树（二叉搜索树、BST）
若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；
若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
任意节点的左、右子树也分别为二叉查找树；
没有键值相等的节点。
- 霍夫曼树
带权路径最短的二叉树称为哈夫曼树或最优二叉树。
- 红黑树
暂时忽略
#### 2、树的性质(只看前四项即可)
1. 在非空二叉树中，第i层的结点总数不超过$2^{(i-1)}$，i>=1
2. 深度为h的二叉树最多有$2^{h}-1$个结点(h>=1)，最少有h个结点
3. 对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1
4. 具有n个结点的完全二叉树的深度为K =$[log_2n]+1$(取下整数)
5. 有N个结点的完全二叉树各结点如果用顺序方式存储，则结点之间有如下关系： 若I为结点编号则如果I>1，则其父结点的编号为I/2
6. 完全二叉树，如果$2*I<=N$，则其左儿子（即左子树的根结点）的编号为$2*I$；若$2*I>N$，则无左儿子； 如果$2*I+1<=N$，则其右儿子的结点编号为$2*I+1$；若$2*I+1>N$，则无右儿子
7. 给定N个节点，能构成h(N)种不同的二叉树。h(N)为卡特兰数的第N项。h(n)=C(2*n，n)/(n+1)
8. 设有i个枝点，I为所有枝点的道路长度总和，J为叶的道路长度总和J=I+2i
#### 3、二叉搜索树和二叉平衡树
二叉平衡树的索引时间复杂度O(n)，n为树的层数，假设n不是树的层数，而是节点数，也就是说整个搜索数据量是n，那么时间复杂度就是O($log_2(n)$)
> 我在看二叉搜索树的时候就在考虑它是如何保证整个树在构建过程中不会偏向一方，导致深度N过大，我的想法是先对整个数据列表进行排序然后通过某个逻辑把最中间的值设置为根结点，以此保证两侧平衡；还有个问题是为什么二叉平衡树一定是二叉搜索树，后来发现二叉平衡树就是二叉搜索树的升级。回到前面的问题，数据有可能在一开始不是完全的，所以会有插入删除等问题，这样总会出现树倾斜的情况，所以关键还是找到调整平衡的方法，有个笨方法是每次对元素操作时都重新构建一次二叉树，这样的目的当然是为了后续索引的效率，但随着数据量越来越大，每次动辄操作就要重新生成所花费的时间也会越来越多，所以并不现实。

#### 4、二叉树创建和添加结点
```python
class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None
    def __str__(self):
        return str(self.value)

class Tree:
    # 构建二叉树
    def __init__(self, value=None):
        if value:
            self.root = Node(value)
        else:
            self.root = None
    # 添加元素
    def add_note(self, value):
        note = Node(value)
        if not self.root:
            self.root = note
        else:
            nodes = [self.root]
            while True:
                n_node = nodes.pop()
                if n_node.left is None:
                    n_node.left = node
                    break
                elif n_node.right is None:
                    n_node.right = node
                    break
                else:
                    nodes.append(n_node.left)
                    nodes.append(n_node.right)
    def get_parent(self, item):
        # 找到item的父节点
        if self.root.data == item:
            return None
        q = [self.root]
        while q:
            pop_node = q.pop(0)
            if pop_node.left and pop_node.left.data == item:
                return pop_node
            elif pop_node.right and pop_node.right.data == item:
                return pop_node
            else:
                if pop_node.left is not None:
                    q.append(pop_node.left)
                if pop_node.right is not None:
                    q.append(pop_node.right)
                return None
    # 删除
    def delete(self, item):
        '''
        从二叉树中删除一个元素
        先获取 待删除节点 item 的父节点
        如果父节点不为空，
            判断 item 的左右子树
            如果左子树为空，那么判断 item 是父节点的左孩子，还是右孩子，如果是左孩子，将父节点的左指针指向 item 的右子树，反之将父节点的右指针指向 item 的右子树
            如果右子树为空，那么判断 item 是父节点的左孩子，还是右孩子，如果是左孩子，将父节点的左指针指向 item 的左子树，反之将父节点的右指针指向 item 的左子树
            如果左右子树均不为空，寻找右子树中的最左叶子节点 x ，将 x 替代要删除的节点。
        删除成功，返回 True
        删除失败, 返回 False

        '''
        if self.root is None:  # 如果根为空，就什么也不做
            return False

        parent = self.get_parent(item)
        if parent:
            del_node = parent.left if parent.left.data == item else parent.right  # 待删除节点
            if del_node.left is None:
                if parent.left.data == item:
                    parent.left = del_node.right
                else:
                    parent.right = del_node.right
                    del del_node
                    return True
            elif del_node.right is None:
                if parent.left.data == item:
                        parent.left = del_node.left
                else:
                    parent.right = del_node.left
                    del del_node
                    return True
            else:  # 左右子树都不为空
                tmp_pre = del_node
                tmp_next = del_node.right
                if tmp_next.left is None:
                    # 替代
                    tmp_pre.right = tmp_next.right
                    tmp_next.left = del_node.left
                    tmp_next.right = del_node.right
                else:
                    while tmp_next.left:  # 让tmp指向右子树的最后一个叶子
                        tmp_pre = tmp_next
                        tmp_next = tmp_next.left
                        # 替代
                        tmp_pre.left = tmp_next.right
                        tmp_next.left = del_node.left
                        tmp_next.right = del_node.right
                        if parent.left.data == item:
                            parent.left = tmp_next
                        else:
                            parent.right = tmp_next
                            del del_node
                            return True
        else:
            return False
```
从我参考的文章来看，普通的二叉树的删除操作是很没有*定义*的，如果被删除的结点只有一个子树还好，当有两个子树的时候，就会发现无法自然地将被删除结点从图中去掉，我参考的文章中实现的逻辑也不是很通顺；另外我发现像python这样的语言实现二叉树的时候与c等语言的一个区别，那就是结点除了值外无法区分，除非再添加一个id属性，而在c等语言里面具有区分作用的是指针，我感觉严格意义上id应该是必要的，但无疑会使得各个操作逻辑上变得复杂；但是从另一个角度，每个Node的实例对象也是唯一的，也好像可以。。

#### 5、二叉搜索树

二叉搜索树的生成大概就是修改了普通二叉树的添加元素操作，改为了插入，每次添加节点时都会比较结点对应值的大小，然后在合适的位置插入；那二叉平衡树又是如何添加结点的呢？
```python
# 二叉搜索树
class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None
        # self.father = None

class BST:
    def __init__(self, value=None):
        if value:
            self.root = Node(value)
        else:
            self.root = None
    # 遍历
    def compare(node, value):
        if not node:
            return None
        if node.value == value:
            return self.root
        elif node.value < value:
            return f(node.left, value)
        else:
            return f(node.right, value)
    def serach(self, value):
        return self.compare(self.root, value)
    # 插入
    def insert(self, value):
        if not self.root:
            self.root = Node(value)
            return
        node = self.root
        while node:
            node_father = node
            if node.value >= value:
                node = node.left
            else:
                node = node.right
        if node_father.value <= value:
            node_father.left = value
        else:
            node_father.right = value
    def _delete_find(node, type_):
        if type_ == 'min':
            if node.left:
                return _delete_find(node.left, 'min')
            else:
                return node, node.value
        else:
            if node.right:
                return _delete_find(node.right, 'max')
            else:
                return node, node.value

    # 删除
    def delete(self, node):
        # 找到被删除的叶子结点和值
        if node.left:
            leaf_node, value = _delete_find(node.left, 'max')
        elif node.right:
            leaf_node, value = _delete_find(node.left, 'min')
        else:
            leaf_node, value = node, None

        # 偷个懒，找父结点不写了
        # 将叶子结点的值赋给被删除的目标结点
        # 删除的是root
        if node.father is None:
            if value is None:
                self.root = None
            else:
                self.root.value = value
        # 删除的是父结点的左子结点
        elif node == node.father.left:
            if value is None:
                node.father.left = None
            else:
                node.father.left.value = value
        # 删除的是父结点的右子结点
        else:
            if value is None:
                node.father.right = None
            else:
                node.father.right.value = value

        # 删除叶子结点
        self.delete(leaf.node)

# 搜索树和平衡树的变换
```
通过参考文章中的`二叉树的删除操作`这篇，我大概懂了之前我上面看到的python实现二叉树那篇文章中的删除逻辑，正如之前说的，被删除的结点同时有左子树和右子树的时候会比较麻烦，但对于搜索二叉树来说，删除后还符合定义的一般就是左子树的最右结点和右子树的最左结点这两个。

#### 6、二叉平衡树
插入和删除操作后任然要保证是平衡的，是通过一个旋转算法实现的
```

```
#### 7、遍历


#### 8、二叉树的使用场景
比起二叉树的操作，我更加好奇这样的数据结构具体在什么样的场景中适合使用呢？在我看来，二叉树最大的优势就是查询速度快，但同样修改删除等操作很复杂抵销了部分优势。




### 5、图
### 6、堆
### 散列表


# 其他

## 时间复杂度和空间复杂度
参考文章：https://zhuanlan.zhihu.com/p/50479555
# 基础数据结构与算法
基础的东西还是会忘，目标是总结常用数据结构的定义，以及python底层实现

## 一、底层结构（物理结构）
### 1.1、 数组
按照目前的定义，数组是一整块连续的内存地址
特点：数据连续，支持快速随机访问

> 为什么支持随机访问？为什么访问快速？
随机访问是指访问一个中间元素时不需要经过前面的元素；访问快速的原因是知道头元素的位置，根据内存位置计算就可以得到目标的位置，时间复杂度O(1)
### 1.2、链表
链表的物理结构与数组不同，由离散的内存地址构建的存储结构

> 为什么说上述两个是底层机构呢？
我的理解，也许数组和链表两个名词不是很准确，但反映的是两种最基础的数据结构底层实现逻辑，即：内存是连续的还是离散的。但是在python中数组指的并不是物理结构，而是一种逻辑结构，即上层的数据结构--线性表。

## 二、上层结构（逻辑结果）

### 2.1、线性表
定义：1）只有一个开始元素，2）只有一个结束元素，3）除开始和结束外，每个元素都只有一个前驱和一个后继
实现方式：
- 数组
- 链式存储
	- 单链表：节点只往后指
	- 双向链表：尾节点指向头节点
	- 循环链表：节点往前往后都可以指

目标功能：
```
ADT List：
   List(self)           #创建一个新表
   is_empty(self)       #判断self是否是一个空表
   len(self)            #返回表长度
   prepend(self,elem)   #在表头插入元素
   append(self,elem)    #在表尾加入元素
   insert(self,elem,i)  #在表的位置i处插入元素
   del_first(self)      #删除第一个元素
   def_last(self)       #删除最后一个元素
   del(self,i)          #删除第I个元素
   search(self,elem)    #查找元素在表中第一次出现的位置
   forall(self,op)      #对表元素的遍历操作，op操作
```

参考文章：
- python列表和元组：https://www.jianshu.com/p/24090fb63968
- python实现单链表，看看就行屁用没有：https://m.yisu.com/zixun/158827.html
- python list原理：https://zhuanlan.zhihu.com/p/143223943

```python
# 其实在python中没必要实现线性表，list类型足够用，但是即便如此，也应该了解list是如何实现的
# 单链表
class LNode():
    def __init__(self, value, next_=None):
        self.value = value
        self.next = next_
class LineLinkedList():
    def __init__(self):
        self.head = None
        self.num = 0
# 累了，不想写了。。，
# 双链表要加个唯一id识别出头节点
# 循环链表就再加个指向前面的属性
```
[别人实现的代码，作为参考](./python_list.py)

问题：
- 1、python内部的数组是如何实现的？

```
# cpython中list的定义
typedef struct {
    PyObject_VAR_HEAD
    PyObject **ob_item;
    Py_ssize_t allocated;
} PyListObject;
```
首先python中的数组是`动态数组`，基本由cpython实现，PyObject是指向列表元素的指针列表，allocated是在内存中分配的插槽数，一般插槽数大于len，这样添加元素时，如果插槽数还剩余就不用申请空间；一旦超过，就需要申请新的空间，每次申请的插槽数不一样，以某种规律增长。
```
# resize
arguments: list object, new size
returns: 0 if OK, -1 if not
list_resize:
    new_allocated = (newsize >> 3) + (newsize < 9 ? 3 : 6) = 3
    new_allocated += newsize = 3 + 1 = 4
    resize ob_item (list of pointers) to size new_allocated
    return 0
# >>：移位运算符
# condition ? value1: value2: 条件判断府，如果符合就是value1，不然value2
```
其次复杂度分析，Appand 操作的时间复杂度 O(1)，Insert 操作的复杂度为O(n)，Pop 操作的复杂度为 O(1)，Remove操作的复杂度为O(n)，都挺好理解的，但是值得注意的是`当删除元素导致列表元素数量小于插槽数一半的时候，插槽数也会减少，即预设的内存会减少`

- 2、python可以实现内存申请吗，像c语言中的数组一样？

在python中tuple很像c语言的数组，创建后不可删除，修改；但是可以实现两个元组的合并，逻辑也很简单，新创建一个元组，读取已有元组中的元素复制到新元组中；元组相较于数组，除了保证数据安全外， 是更加内存友好的结构，即`占用内存更少、创建速度更快、与python普通回收不同，元组删除后，内存不会立刻返回给os暂留，可避免频繁与os交互`（这应该是优势吧？暂留真的不会影响效率吗？）

### 2.2、栈
后进先出
``` python
class Stack:
  def __init__(self, *args):
            self.stack = list(args)
    def push(self, element):
            self.stack.append(element)
    def pop(self):
            return self.stack.pop()
    def __str__(self):
            return str(self.stack)
# 其他方法就不写了，懒
```
其实基本思想没啥特别的，总结几个面试类型
1. 括号匹配
2. 两个栈实现队列
3. 栈的压入、弹出序列


- 括号的很基础
- 两个栈的是一个进，一个出，当出的栈为空的时候就把进栈的元素压入出栈，然后在输出
- 这个是判断弹出序列是否是对的，其实可以简化为判断输入输出序列中是否存在连续的两个数字，用指针就可以解决；当然也可以真的去压入一遍，时刻比较栈顶元素与输出元素是否一致，全部压入之后，如果还是有剩余元素，则不一致

### 3、队列
先进先出，只允许队头删除，队尾插入
``` python
class Queue:
    def __init__(self, *args):
            self.queue = list(args)
    def enqueue(self, element):
            self.queue.append(element)
    def dequeue(self):
            last = self.queue[0]
            del self.queue[0]
            return last
    def __str__(self):
            return str(self.queue)
# 这样写也算，但意义不大
```

介绍python中的队列类
- collections.deque：双端队列，结合了栈和队列的类型，可操作队头队尾的插入和删除
- Queue：这个类最初是在多线程的时候用到

### 4、二叉树
参考：

- 树相关的属性和性质：https://www.cnblogs.com/guoyaohua/p/8595289.html
- 二叉树的性质：https://www.jianshu.com/p/20c8881c6b86
- 各种树的定义：https://blog.csdn.net/u014532217/article/details/79118023
- 二叉搜索树(BST)与平衡二叉树(AVL树)专题：https://blog.csdn.net/DaveBobo/article/details/77603549
- 构建二叉树：https://developer.aliyun.com/article/616378
- 构建二叉树python实现：https://www.pythonf.cn/read/134131
- 二叉树的删除操作：https://blog.csdn.net/zxnsirius/article/details/52131433
- 平衡二叉树旋转示意图：https://www.jianshu.com/p/d802766551ff
- 平衡二叉树python实现：https://blog.csdn.net/qq_34840129/article/details/80728186
- 二叉树遍历递归与迭代实现：https://zhuanlan.zhihu.com/p/56895993

#### 2.4.1、树的类型
- 无序树
树的任意节点的子节点没有顺序关系。
- 有序树
树的任意节点的子节点有顺序关系。
- 二叉树
树的任意节点至多包含两棵子树。
- 满二叉树
叶子节点都在同一层并且除叶子节点外的所有节点都有两个子节点。
- 完全二叉树
对于一颗二叉树，假设其深度为d（d>1）。除第d层外的所有节点构成满二叉树，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树；
PS：这里的满二叉树和完全二叉树取的是国内的定义，国外的定义不一样，有兴趣的可以去看看国外的定义。
- 平衡二叉树（AVL）
它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树，同时，`平衡二叉树必定是二叉搜索树`，因为平衡二叉树是在二叉搜索树的基础上实现的
- 二叉查找树（二叉搜索树、BST）
若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；
若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
任意节点的左、右子树也分别为二叉查找树；
没有键值相等的节点。
- 霍夫曼树
带权路径最短的二叉树称为哈夫曼树或最优二叉树。
- 红黑树
暂时忽略
- B树/B+树
#### 2.4.2、树的性质(只看前四项即可)
1. 在非空二叉树中，第i层的结点总数不超过$2^{(i-1)}$，i>=1
2. 深度为h的二叉树最多有$2^{h}-1$个结点(h>=1)，最少有h个结点
3. 对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1
4. 具有n个结点的完全二叉树的深度为K =$[log_2n]+1$(取下整数)
5. 有N个结点的完全二叉树各结点如果用顺序方式存储，则结点之间有如下关系： 若I为结点编号则如果I>1，则其父结点的编号为I/2
6. 完全二叉树，如果$2*I<=N$，则其左儿子（即左子树的根结点）的编号为$2*I$；若$2*I>N$，则无左儿子； 如果$2*I+1<=N$，则其右儿子的结点编号为$2*I+1$；若$2*I+1>N$，则无右儿子
7. 给定N个节点，能构成h(N)种不同的二叉树。h(N)为卡特兰数的第N项。$h(n)=C(2*n，n)/(n+1)$
8. 设有i个枝点，$I$为所有枝点的道路长度总和，J为叶的道路长度总和$J=I+2i$

#### 2.4.3、二叉搜索树和二叉平衡树
二叉平衡树的索引时间复杂度O(n)，n为树的层数，假设n不是树的层数，而是节点数，也就是说整个搜索数据量是n，那么时间复杂度就是O($log_2(n)$)
> 我在看二叉搜索树的时候就在考虑它是如何保证整个树在构建过程中不会偏向一方，导致深度N过大，我的想法是先对整个数据列表进行排序然后通过某个逻辑把最中间的值设置为根结点，以此保证两侧平衡；还有个问题是为什么二叉平衡树一定是二叉搜索树，后来发现二叉平衡树就是二叉搜索树的升级。回到前面的问题，数据有可能在一开始不是完全的，所以会有插入删除等问题，这样总会出现树倾斜的情况，所以关键还是找到调整平衡的方法，有个笨方法是每次对元素操作时都重新构建一次二叉树，这样的目的当然是为了后续索引的效率，但随着数据量越来越大，每次动辄操作就要重新生成所花费的时间也会越来越多，所以并不现实。

#### 2.4.4、二叉树创建和添加结点

[二叉树实现代码](./binary_tree.py)

从我参考的文章来看，普通的二叉树的删除操作是很没有*定义*的，如果被删除的结点只有一个子树还好，当有两个子树的时候，就会发现无法自然地将被删除结点从图中去掉，我参考的文章中实现的逻辑也不是很通顺；另外我发现像python这样的语言实现二叉树的时候与c等语言的一个区别，那就是结点除了值外无法区分，除非再添加一个id属性，而在c等语言里面具有区分作用的是指针，我感觉严格意义上id应该是必要的，但无疑会使得各个操作逻辑上变得复杂；但是从另一个角度，每个Node的实例对象也是唯一的，也好像可以。。

#### 2.4.5、二叉搜索树

[BST树具体实现代码](./bst.py)

二叉搜索树的生成大概就是修改了普通二叉树的添加元素操作，改为了插入，每次添加节点时都会比较结点对应值的大小，然后在合适的位置插入；那二叉平衡树又是如何添加结点的呢？

通过参考文章中的[二叉搜索树](https://blog.csdn.net/zxnsirius/article/details/52131433)这篇，我大概懂了之前我上面看到的python实现二叉树那篇文章中的删除逻辑，正如之前说的，被删除的结点同时有左子树和右子树的时候会比较麻烦，但对于搜索二叉树来说，删除后还符合定义的一般就是左子树的最右结点和右子树的最左结点这两个。

通过上面的可执行代码，我发现一个问题，例如下面的树
```
tree_1:
                     10                                              
         5                       20                      
   0           *           15          25          
*     3     *     *     12    17    22    30  
tree_2:
                     10                                               
         3                       20                      
   0           *           15          25          
*     *     *     *     12    17    22    30 
tree_3:
                     10                                              
         0                       20                      
   *           3           15          25          
*     *     *     *     12    17    22    30 
```

试问tree_1中的5结点被删除后，是变成tree_2呢？还是变成tree_3呢？如果删除逻辑是把5的左子树直接给10的左子树的话，就是tree_3；如果像我一样，会去找左子树中的最大值，然后替换删除就是tree_2；

```
tree_1:
                     5
         4                       6
   2           *           *           8
1     3     *     *     *     *     7     9
tree_2:
                     4
         2                       6
   1           3           *           8
*     *     *     *     *     *     7     9
tree_3:
                     4
         3                       6
   2           *           *           8
1     *     *     *     *     *     7     9
```
同样，被删除的是10结点的话，也会有这样的问题；这两者是否有优劣之分呢？

> 两种删除都已经实现，但感觉逻辑还没有达到最精简的程度，依旧有些绕

#### 2.4.6、二叉平衡树

[AVL树具体实现代码](./avl.py)

##### 概念
bf值：当前结点的左子树高度减去右子树的高度之差
旋转算法：插入和删除操作后任然要保证是平衡的，是通过一个旋转算法实现的

记录bf值跟记录高度本质应该是一样的，一般会创建一个计算高度或者bf值的函数，或者，每次插入删除后都修改一遍属性
##### 关键
1、avl树添加元素的关键我感觉只有两个，一个是旋转方向的判定，另一个是旋转算法的实现
- 1、方向判定
判断选装方向需要三个结点：插入结点，不平衡结点左结点/右结点，以及不平衡结点
如果插入结点的值小于不平衡结点，那么就是第一个l，如果同时小于不平衡结点的左结点，那就是ll，如果大于不平衡结点的左结点，那就是lr；
如果插入结点的值大于不平衡结点，那么就是第一个r，如果同时小于不平衡结点的右结点，那就是rl，如果大于不平衡结点的右结点，那就是rr；
- 2、旋转算法逻辑
如果是ll，插入结点和不平衡结点变成不平衡结点左结点的两个子结点；
如果是rr，插入结点和不平衡结点变成不平衡结点右结点的两个子结点；
如果是lr，就会出现第三个关键结点：待拆分结点，待拆分结点的左右子树被拆分出来，左子树作为不平衡结点左结点的右结点，右子树作为不平衡结点的左结点，而不平衡结点的左结点和不平衡结点本身成为待拆分结点的左右结点；
如果是rl，待拆分结点的左右子树被拆分出来，左子树作为不平衡结点的右结点，右子树作为不平衡结点右结点的左结点，而不平衡结点和不平衡结点的右结点本身成为待拆分结点的左右结点；

2、avl的删除，与插入不同，当删除一个结点的时候，可能会出现多个不平衡的情况，例如下面删除结点8的时候，就会出现5-4-3这种ll型的，以及5-4-4.5这种lr类型的。

```
         5
   4           8
3   4.5     *     *
```
我能想到的粗暴方法就是，直接找出高度最高的一层结点，然后取第一个，处理方法将该结点等价于插入结点再平衡，如下。
```
         4
   3           5
*     *   4.5     *
```

##### 复杂度
查询$O(log_2N)$，频繁旋转会使插入和删除牺牲掉$O(logN)$，这个复杂度是指查询的复杂度？

##### 问题
1、bf值每次要更新全部结点，感觉效率太低了，可以优化


#### 2.4.7、遍历

相比之下，遍历反而不是很复杂，一般从路径的角度有以下方式，从方向的角度，前三种属于深度优先，第四种属于广度优先
- 前序遍历：根结点->左结点->右结点
- 中序遍历：左结点->根结点->右结点
- 后序遍历：左结点->右结点>根结点-
- 层序遍历：一层一层

实现代码也写在了[AVL树具体实现代码](./avl.py)

> 递归是很耗费计算机资源的，所以我们在写程序的时候要尽量避免使用递归。幸运的是，绝大部分递归的代码都有相应的迭代版本

这个我倒没有考虑过，说起来使用递归的场合也并没有遇到很多。二叉树遍历的递归实现很简单，但迭代方式却很绕。除了后序遍历之前，其他遍历的迭代方式已经实现，基本应该是没有问题的。后序遍历过于复杂，参考文章一时也想不清楚，以后再说。


#### 2.4.7、霍夫曼树
#### 2.4.7、B树，B+树，B\*树
B树和B+树非常典型的场景就是用于关系型数据库的索引(MySQL)


#### 2.4.8、二叉树的使用场景
比起二叉树的操作，我更加好奇这样的数据结构具体在什么样的场景中适合使用呢？在我看来，二叉树最大的优势就是查询速度快，但同样修改删除等操作很复杂抵销了部分优势。





### 2.5、图
### 2.6、堆
### 散列表
### 哈希冲突


# 其他

## 时间复杂度和空间复杂度
参考文章：https://zhuanlan.zhihu.com/p/50479555
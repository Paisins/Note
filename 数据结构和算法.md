# 基础数据结构
基础的东西还是会忘，目标是总结常用数据结构的定义，以及python底层实现

## 一、底层结构（物理结构）
### 1、 数组
按照目前的定义，数组是一整块连续的内存地址
特点：数据连续，支持快速随机访问
> 为什么支持随机访问？为什么访问快速？
随机访问是指访问一个中间元素时不需要经过前面的元素；访问快速的原因是知道头元素的位置，根据内存位置计算就可以得到目标的位置，时间复杂度O(1)
### 2、链表
链表的物理结构与数组不同，由离散的内存地址构建的存储结构

> 为什么说上述两个是底层机构呢？
我的理解，也许数组和链表两个名词不是很准确，但反映的是两种最基础的数据结构底层实现逻辑，即：内存是连续的还是离散的。但是在python中数组指的并不是物理结构，而是一种逻辑结构，即上层的数据结构--线性表。

## 二、上层结构（逻辑结果）

### 1、线性表
定义：1）只有一个开始元素，2）只有一个结束元素，3）除开始和结束外，每个元素都只有一个前驱和一个后继
实现方式：
- 数组
- 链式存储
	- 单链表：节点只往后指
	- 双向链表：尾节点指向头节点
	- 循环链表：节点往前往后都可以指

目标功能：
```
ADT List：
   List(self)           #创建一个新表
   is_empty(self)       #判断self是否是一个空表
   len(self)            #返回表长度
   prepend(self,elem)   #在表头插入元素
   append(self,elem)    #在表尾加入元素
   insert(self,elem,i)  #在表的位置i处插入元素
   del_first(self)      #删除第一个元素
   def_last(self)       #删除最后一个元素
   del(self,i)          #删除第I个元素
   search(self,elem)    #查找元素在表中第一次出现的位置
   forall(self,op)      #对表元素的遍历操作，op操作
```

参考文章：
- python列表和元组：https://www.jianshu.com/p/24090fb63968
- 实现单链表，看看就行屁用没有：https://m.yisu.com/zixun/158827.html
- python list原理：https://zhuanlan.zhihu.com/p/143223943

```python
# 其实在python中没必要实现线性表，list类型足够用，但是即便如此，也应该了解list是如何实现的
# 单链表
class LNode():
		def __init__(self, value, next_=None):
			self.value = value
			self.next = next_
class LineLinkedList():
		def __init__(self):
			self.head = None
			self.num = 0
# 累了，不想写了。。，
# 双链表要加个唯一id识别出头节点
# 循环链表就再加个指向前面的属性

# 别人的
class Node(object):
  """节点"""

  def __init__(self, elem):
    self.elem = elem
    self.next = None # 初始设置下一节点为空


class SingleLinkList(object):
  """单链表"""

  def __init__(self, node=None): # 使用一个默认参数，在传入头结点时则接收，在没有传入时，就默认头结点为空
    self.__head = node

  def is_empty(self):
    '''链表是否为空'''
    return self.__head == None

  def length(self):
    '''链表长度'''
    # cur游标，用来移动遍历节点
    cur = self.__head
    # count记录数量
    count = 0
    while cur != None:
      count += 1
      cur = cur.next
    return count

  def travel(self):
    '''遍历整个列表'''
    cur = self.__head
    while cur != None:
      print(cur.elem, end=' ')
      cur = cur.next
    print("\n")

  def add(self, item):
    '''链表头部添加元素'''
    node = Node(item)
    node.next = self.__head
    self.__head = node

  def append(self, item):
    '''链表尾部添加元素'''
    node = Node(item)
    # 由于特殊情况当链表为空时没有next，所以在前面要做个判断
    if self.is_empty():
      self.__head = node
    else:
      cur = self.__head
      while cur.next != None:
        cur = cur.next
      cur.next = node

  def insert(self, pos, item):
    '''指定位置添加元素'''
    if pos <= 0:
        # 如果pos位置在0或者以前，那么都当做头插法来做
      self.add(item)
    elif pos > self.length() - 1:
      # 如果pos位置比原链表长，那么都当做尾插法来做
      self.append(item)
    else:
      per = self.__head
      count = 0
      while count < pos - 1:
        count += 1
        per = per.next
      # 当循环退出后，pre指向pos-1位置
      node = Node(item)
      node.next = per.next
      per.next = node

  def remove(self, item):
    '''删除节点'''
    cur = self.__head
    pre = None
    while cur != None:
      if cur.elem == item:
        # 先判断该节点是否是头结点
        if cur == self.__head:
          self.__head = cur.next
        else:
          pre.next = cur.next
        break
      else:
        pre = cur
        cur = cur.next

  def search(self, item):
    '''查找节点是否存在'''
    cur = self.__head
    while not cur:
      if cur.elem == item:
        return True
      else:
        cur = cur.next
    return False


if __name__ == "__main__":

    # node = Node(100) # 先创建一个节点传进去

  ll = SingleLinkList()
  print(ll.is_empty())
  print(ll.length())

  ll.append(3)
  ll.add(999)
  ll.insert(-3, 110)
  ll.insert(99, 111)
  print(ll.is_empty())
  print(ll.length())
  ll.travel()
  ll.remove(111)
  ll.travel()
```

问题：
- 1、python内部的数组是如何实现的？

```
# cpython中list的定义
typedef struct {
    PyObject_VAR_HEAD
    PyObject **ob_item;
    Py_ssize_t allocated;
} PyListObject;
# resize
arguments: list object, new size
returns: 0 if OK, -1 if not
```
首先python中的数组是`动态数组`，基本由cpython实现，PyObject是指向列表元素的指针列表，allocated是在内存中分配的插槽数，一般插槽数大于len，这样添加元素时，如果插槽数还剩余就不用申请空间；一旦超过，就需要申请新的空间，每次申请的插槽数不一样，以某种规律增长。
```
list_resize:
    new_allocated = (newsize >> 3) + (newsize < 9 ? 3 : 6) = 3
    new_allocated += newsize = 3 + 1 = 4
    resize ob_item (list of pointers) to size new_allocated
    return 0
# >>：移位运算符
# condition ? value1: value2: 条件判断府，如果符合就是value1，不然value2
```
其次复杂度分析，Appand 操作的时间复杂度 O(1)，Insert 操作的复杂度为O(n)，Pop 操作的复杂度为 O(1)，Remove操作的复杂度为O(n)，都挺好理解的，但是值得注意的是`当删除元素导致列表元素数量小于插槽数一半的时候，插槽数也会减少，即预设的内存会减少`

- 2、python可以实现内存申请吗，像c语言中的数组一样？

在python中tuple很像c语言的数组，创建后不可删除，修改；但是可以实现两个元组的合并，逻辑也很简单，新创建一个元组，读取已有元组中的元素复制到新元组中；元组相较于数组，除了保证数据安全外， 是更加内存友好的结构，即`占用内存更少、创建速度更快、与python普通回收不同，元组删除后，内存不会立刻返回给os暂留，可避免频繁与os交互`（这应该是优势吧？暂留真的不会影响效率吗？）

## 栈
后进先出

## 队列
先进先出
## 二叉树
## 图
## 堆
## 散列表


# 其他

## 时间复杂度和空间复杂度
参考文章：https://zhuanlan.zhihu.com/p/50479555
# 计算机网络

## 一、网络体系分层

### 1.1 七层协议
1. 应用层：规定应用程序的数据格式
2. 表示层：
3. 会话层：
4. 传输层：建立"端口到端口"的通信
5. 网络层：ip协议
6. 数据链路层：电信号分组方式。
7. 物理层：传输电信号
### 1.2 四层协议

应用层
运输层
网络层
网络接口层

## 二、互联网协议
参考：
[互联网协议入门(一)](https://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html)

### 2.1 mac地址
> 每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。
> MAC地址有局限性，如果两台电脑不在同一个子网络，就无法知道对方的MAC地址，必须通过网关（gateway）转发

### 2.2 数据链路层
以太网规定
>"标头"包含数据包的一些说明项，比如发送者、接受者、数据类型等等；"数据"则是数据包的具体内容。
"标头"的长度，固定为18字节。"数据"的长度，最短为46字节，最长为1500字节。因此，整个"帧"最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。

### 2.3 广播
> 就算有了MAC地址，系统怎样才能把数据包准确送到接收方？
回答是以太网采用了一种很"原始"的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。

### 2.4 ip地址
> IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。
> 知道"子网掩码"，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0）
> 回答是不需要，我们可以把IP数据包直接放进以太网数据包的"数据"部分，因此完全不用修改以太网的规格。这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构。

### 2.5 arp协议
> 总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。

### 2.6 传输层
> "传输层"的功能，就是建立"端口到端口"的通信。相比之下，"网络层"的功能是建立"主机到主机"的通信。只要确定主机和端口，我们就能实现程序之间的交流。

### 2.7 UDP协议
> 必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议
UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。

### 2.8 TCP协议
> TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。
> TCP数据包和UDP数据包一样，都是内嵌在IP数据包的"数据"部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。

### 2.9 应用层
> TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了"应用层"。

## 三、 socket

参考：
[理解socket](https://blog.csdn.net/StromMaybin/article/details/73010280)
[python socket编程](https://keelii.com/2018/09/24/socket-programming-in-python/)

为什么需要掌握socket编程？

## 四、tcp建立连接和断开
参考：
[TCP的三次握手与四次挥手理解及面试题](https://blog.csdn.net/qq_38950316/article/details/81087809)
[TCP报文格式](https://www.cnblogs.com/aspirant/p/7224696.html)


### 三次握手

- 客户端-服务端：发送syn（同步序列编号）包，序列号为j，进入syn_sent状态
- 服务端-客户端：发送syn包（k）和ack包（j+1），进入syn_recv状态
- 客户端-服务端：发送ack包（k+1），双方进入连接建立的状态

### 四次挥手

- 主动关闭方-被动关闭方：发送一个fin包，我就要关闭连接了
- 被动关闭方-主动关闭方：发送一个ack包，表明已经收到了
- 被动关闭方-主动关闭方：发送-个fin包，我也要关闭了
- 主动关闭方-被动关闭方：发送一个ack包，好的，都进入关闭的状态

报文结构：(flag='ACK', ACK=1)，(flag='SYN', SYN=1)

假使双方同时关闭呢？假使服务端提出关闭也是一样的吗？

## 常见问题
[经典面试题：从URL 输入到页面展现到底发生什么](https://blog.fundebug.com/2019/02/28/what-happens-from-url-to-webpage/)
[终于有人把正向代理和反向代理解释的明明白白了](https://cloud.tencent.com/developer/article/1418457)

# 计算机系统

## 进程、线程和协程
[如何回答面试官提出的关于进程、线程和协程的问题](https://blog.csdn.net/wanghao72214/article/details/109555398)
[协程究竟比线程能省多少开销？](https://zhuanlan.zhihu.com/p/80037638)
[为什么协程切换的代价比线程切换低? - 暗淡了乌云的回答 - 知乎](https://www.zhihu.com/question/308641794/answer/572499202)

进程是操作系统分配资源的最小单元, 线程是操作系统调度的最小单元，协程是用户级的线程

> 进程：代码段用来存放处理器执行的代码；数据段存放全局和静态变量；堆用来存放动态分配的内存；栈用来存放局部变量、函数参数和寄存器的值等。
> 线程：它与同属一个进程的其他的线程共享进程拥有的资源，线程独自拥有少量的程序计数器、数据寄存器和栈等运行中必不可少的私有资源。
> 协程有自己的上下文，同属一个进程的协程共享进程拥有的系统资源。协程的切换由自己控制，由切换到其他协程由当前协程来控制。与线程和进程相比，协程的最大优势在于其“轻量级”，可以轻松创建上百万个而不会导致系统资源衰竭。

- 为什么协程可以创建的数量远大于线程和进程？
创建协程所需要的内存资源远远小于进程和线程
> 在空间上，协程初始化创建的时候为其分配的栈有2KB。而线程栈要比这个数字大的多，可以通过ulimit 命令查看，一般都在几兆

- 为什么协程切换速度比线程和进程都要快？
> 我们用实验的方式验证了Linux进程和线程的上下文切换开销，大约是3-5us之间
> 平均每次协程切换的开销是（655035993-415197171)/2000000=120ns。相对于前面文章测得的进程切换开销大约3.5us，大约是其的三十分之一。比系统调用的造成的开销还要低。
> 所谓进程切换就是从运行中的进程中收回处理器，然后再使待运行进程来占用处理器。从某个进程收回处理器，实质上就是把进程运行过程中寄存器的中间数据存放到进程的堆栈。让某个进程来占用处理器，实质上是把这个进程存放在堆栈中的寄存器数据恢复到处理器的寄存器中去，并把待运行进程的断点送入处理器的程序计数器。
> 一个进程存储在处理器各寄存器中的中间数据叫做进程的上下文，所以进程切换就是被中止进程与待运行进程上下文的切换。进程切换上下文时，需要进出操作系统内核，并进行寄存器数据切换等工作，都需要一定的时间开销。
> 线程切换除了上下文的切换外，还有内核调度的消耗，例如一些用户态状态切换等等，但协程只需要切换上下文即可，可能是因为这里使得协程的切换效率更高

写线程和协程的时候也有感觉，线程是由系统调度的，用户只是给线程分配了任务，但是协程是自己调度的，用户需要设置协程切换的位置。

## 通信
[](https://www.cnblogs.com/MrListening/p/5858358.html)
进程之间进行通信常用的有几种方式：管道，消息队列， 信号量， 共享内存；线程同步通常有4中方式： 临界区、事件、互斥量、信号量。
线程通信

### 管道：
匿名管道：双工的通信方式，只允许亲缘进程通信
有名管道：双工的通信方式，允许非亲缘进程通信
特点：
1. 只能单向通信
2. 只能血缘关系的进程进行通信
3. 依赖于文件系统
4、生命周期随进程

### 信号量
信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

### 消息队列
消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

### 信号
信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

### 共享内存
共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。

### 套接字
套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。


## 进程
[进程间8种通信方式详解](https://cloud.tencent.com/developer/article/1690556)
进程有5种状态：
新建态：刚刚创建的进程，操作系统还没有把它加入到可执行进程组中，通常是进程控制块已经创建但是还没有加载到内存中的进程。
就绪态：进程已经做好了准备，只要有机会就开始执行。
运行态：该进程正在执行。
阻塞态（等待态）：进程在某些事情发生前不能执行，等待阻塞进程的事件完成。
退出态：操作系统从可执行进程组中释放出的进程，由于自身或某种原因停止运行。

## 线程
### 多线程同步
[Python信号量](https://haicoder.net/python/python-thread-semaphore.html)
[进程间通信的方式（四）：信号量](https://zhuanlan.zhihu.com/p/37894026)
信号量到底是用来限制资源访问，还是用来同步不同的线程信息的？
> 同步：处理竞争就是同步，安排进程执行的先后顺序就是同步，每个进程都有一定的个先后执行顺序。
互斥：互斥访问不可共享的临界资源，同时会引发两个新的控制问题（互斥可以说是特殊的同步）。
竞争：当并发进程竞争使用同一个资源的时候，我们就称为竞争进程。
> 共享资源通常分为两类：一类是互斥共享资源，即任一时刻只允许一个进程访问该资源；另一类是同步共享资源，即同一时刻允许多个进程访问该资源；信号量是解决互斥共享资源的同步问题而引入的机制。

原来是我没有理解到同步的意思

> 信号量是由操作系统管理的一种抽象数据类型，用于在多线程中同步对共享资源的使用。本质上说，信号量是一个内部数据，用于标明当前的共享资源可以有多少并发读取。
也可以简单的理解为，信号量是多把锁，同时允许多个线程来更改数据，而互斥锁同时只允许一个线程更改数据。Python信号量使用语法：
```
import threading
sem = threading.Semaphore(3)
sem.acquire()
sem.release()
```

## 内存
缓存区溢出指计算机在向缓存区填充数据时超过了缓存区的最大值， 溢出的数据覆盖在了合法数据上。
其危害： 程序崩溃， 导致拒绝服务。跳转并执行恶意代码。
造成缓存区溢出的原因主要是没有对用户的输入进行检查。



# linux
## 一些常用操作（面试）
查看端口号是否被占用
netstat -anp|grep 80

如何为一个目录下的所有文件添加权限
r：4，w：2，x：1
chmod -R 777 apache-tomcat-8.5.20/

如果要删除一个文件，那么需要拥有这个文件所在目录的write权限

## linux io模式
[彻底理解 IO 多路复用实现机制](https://juejin.cn/post/6882984260672847879) 待看

## 监控命令
```
# 查看丢包和延时
mtr google.com
# iperf测试带宽，iperf是c/s模型应用，所以必须先运行iperf server
# 在一台主机上（服务端）：
iperf -u -s
# 另一台主机上（客户端）：
iperf -u -c 10.0.0.1(服务端的ip地址)
# 第一个参数是采样的时间间隔数，单位是秒，第二个参数是采样的次数，如果不设置第二个参数，那么可以一直运行
# 可以查看cpu、内存、io
vmstat 2 1
```

